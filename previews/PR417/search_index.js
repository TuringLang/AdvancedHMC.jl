var documenterSearchIndex = {"docs":
[{"location":"get_started/#Sampling-from-a-multivariate-Gaussian-using-NUTS","page":"Get Started","title":"Sampling from a multivariate Gaussian using NUTS","text":"","category":"section"},{"location":"get_started/","page":"Get Started","title":"Get Started","text":"In this section, we demonstrate a minimal example of sampling from a multivariate Gaussian (10-dimensional) using the No U-Turn Sampler (NUTS). Below we describe the major components of the Hamiltonian system which are essential to sample using this approach:","category":"page"},{"location":"get_started/","page":"Get Started","title":"Get Started","text":"Metric: In many sampling problems the sample space is associated with a metric that allows us to measure the distance between any two points, and other similar quantities. In the example in this section, we use a special metric called the Euclidean Metric, represented with a D × D matrix from which we can compute distances.[1]\nLeapfrog integration: Leapfrog integration is a second-order numerical method for integrating differential equations (In this case they are equations of motion for the relative position of one particle with respect to the other). The order of this integration signifies its rate of convergence. Any algorithm with a finite time step size will have numerical errors, and the order is related to this error. For a second-order algorithm, this error scales as the second power of the time step, hence the name. High-order integrators are usually complex to code and have a limited region of convergence; thus they do not allow arbitrarily large time steps. A second-order integrator is suitable for our purpose. Hence we opt for the leapfrog integrator. It is called leapfrog due to the ways this algorithm is written, where the positions and velocities of particles \"leap over\" each other.[2]\nKernel for trajectories (static or dynamic): Different kernels, which may be static or dynamic, can be used. At each iteration of any variant of the HMC algorithm, there are two main steps - the first step changes the momentum and the second step may change both the position and the momentum of a particle.[3]","category":"page"},{"location":"get_started/","page":"Get Started","title":"Get Started","text":"using AdvancedHMC, ForwardDiff\nusing LogDensityProblems\nusing LinearAlgebra\n\n# Define the target distribution using the `LogDensityProblem` interface\nstruct LogTargetDensity\n    dim::Int\nend\nLogDensityProblems.logdensity(p::LogTargetDensity, θ) = -sum(abs2, θ) / 2  # standard multivariate normal\nLogDensityProblems.dimension(p::LogTargetDensity) = p.dim\nfunction LogDensityProblems.capabilities(::Type{LogTargetDensity})\n    return LogDensityProblems.LogDensityOrder{0}()\nend\n\n# Choose parameter dimensionality and initial parameter value\nD = 10;\ninitial_θ = rand(D);\nℓπ = LogTargetDensity(D)\n\n# Set the number of samples to draw and warmup iterations\nn_samples, n_adapts = 2_000, 1_000\n\n# Define a Hamiltonian system\nmetric = DiagEuclideanMetric(D)\nhamiltonian = Hamiltonian(metric, ℓπ, ForwardDiff)\n\n# Define a leapfrog solver, with the initial step size chosen heuristically\ninitial_ϵ = find_good_stepsize(hamiltonian, initial_θ)\nintegrator = Leapfrog(initial_ϵ)\n\n# Define an HMC sampler with the following components\n#   - multinomial sampling scheme,\n#   - generalised No-U-Turn criteria, and\n#   - windowed adaption for step-size and diagonal mass matrix\nkernel = HMCKernel(Trajectory{MultinomialTS}(integrator, GeneralisedNoUTurn()))\nadaptor = StanHMCAdaptor(MassMatrixAdaptor(metric), StepSizeAdaptor(0.8, integrator))\n\n# Run the sampler to draw samples from the specified Gaussian, where\n#   - `samples` will store the samples\n#   - `stats` will store diagnostic statistics for each sample\nsamples, stats = sample(\n    hamiltonian, kernel, initial_θ, n_samples, adaptor, n_adapts; progress=true\n)","category":"page"},{"location":"get_started/#Parallel-Sampling","page":"Get Started","title":"Parallel Sampling","text":"","category":"section"},{"location":"get_started/","page":"Get Started","title":"Get Started","text":"AdvancedHMC enables parallel sampling (either distributed or multi-thread) via Julia's parallel computing functions. It also supports vectorized sampling for static HMC.","category":"page"},{"location":"get_started/","page":"Get Started","title":"Get Started","text":"The below example utilizes the @threads macro to sample 4 chains across 4 threads.","category":"page"},{"location":"get_started/","page":"Get Started","title":"Get Started","text":"# Ensure that Julia was launched with an appropriate number of threads\nprintln(Threads.nthreads())\n\n# Number of chains to sample\nnchains = 4\n\n# Cache to store the chains\nchains = Vector{Any}(undef, nchains)\n\n# The `samples` from each parallel chain is stored in the `chains` vector \n# Adjust the `verbose` flag as per need\nThreads.@threads for i in 1:nchains\n    samples, stats = sample(\n        hamiltonian, kernel, initial_θ, n_samples, adaptor, n_adapts; verbose=false\n    )\n    chains[i] = samples\nend","category":"page"},{"location":"get_started/#Using-the-AbstractMCMC-Interface","page":"Get Started","title":"Using the AbstractMCMC Interface","text":"","category":"section"},{"location":"get_started/","page":"Get Started","title":"Get Started","text":"Users can also use the AbstractMCMC interface to sample, which is also used in Turing.jl. In order to show how this is done let us start from our previous example where we defined a LogTargetDensity, ℓπ.","category":"page"},{"location":"get_started/","page":"Get Started","title":"Get Started","text":"using AbstractMCMC, LogDensityProblemsAD\n\n# Wrap the previous LogTargetDensity as LogDensityModel \n# where ℓπ::LogTargetDensity\nmodel = AdvancedHMC.LogDensityModel(LogDensityProblemsAD.ADgradient(Val(:ForwardDiff), ℓπ))\n\n# Wrap the previous sampler as a HMCSampler <: AbstractMCMC.AbstractSampler\nD = 10;\ninitial_θ = rand(D);\nn_samples, n_adapts, δ = 1_000, 2_000, 0.8\nsampler = HMCSampler(kernel, metric, adaptor)\n\n# Now sample\nsamples = AbstractMCMC.sample(\n    model, sampler, n_adapts + n_samples; n_adapts=n_adapts, initial_params=initial_θ\n)","category":"page"},{"location":"get_started/#Convenience-Constructors","page":"Get Started","title":"Convenience Constructors","text":"","category":"section"},{"location":"get_started/","page":"Get Started","title":"Get Started","text":"In the previous examples, we built the sampler by manually specifying the integrator, metric, kernel, and adaptor to build our own sampler. However, in many cases, users might want to initialize a standard NUTS sampler. In such cases having to define each of these aspects manually is tedious and error-prone. For these reasons AdvancedHMC also provides users with a series of convenience constructors for standard samplers. We will now show how to use them.","category":"page"},{"location":"get_started/","page":"Get Started","title":"Get Started","text":"HMC:\n# HMC Sampler\n# step size, number of leapfrog steps \nn_leapfrog, ϵ = 25, 0.1\nhmc = HMC(ϵ, n_leapfrog)\nis equivalent to:\nmetric = DiagEuclideanMetric(D)\nhamiltonian = Hamiltonian(metric, ℓπ, ForwardDiff)\nintegrator = Leapfrog(0.1)\nkernel = HMCKernel(Trajectory{EndPointTS}(integrator, FixedNSteps(n_leapfrog)))\nadaptor = NoAdaptation()\nhmc = HMCSampler(kernel, metric, adaptor)\nNUTS:\n# NUTS Sampler\n# adaptation steps, target acceptance probability,\nδ = 0.8\nnuts = NUTS(δ)\nis equivalent to:\nmetric = DiagEuclideanMetric(D)\nhamiltonian = Hamiltonian(metric, ℓπ, ForwardDiff)\ninitial_ϵ = find_good_stepsize(hamiltonian, initial_θ)\nintegrator = Leapfrog(initial_ϵ)\nkernel = HMCKernel(Trajectory{MultinomialTS}(integrator, GeneralisedNoUTurn()))\nadaptor = StanHMCAdaptor(MassMatrixAdaptor(metric), StepSizeAdaptor(δ, integrator))\nnuts = HMCSampler(kernel, metric, adaptor)\nHMCDA:\n#HMCDA (dual averaging)\n# adaptation steps, target acceptance probability, target trajectory length \nδ, λ = 0.8, 1.0\nhmcda = HMCDA(δ, λ)\nis equivalent to:\nmetric = DiagEuclideanMetric(D)\nhamiltonian = Hamiltonian(metric, ℓπ, ForwardDiff)\ninitial_ϵ = find_good_stepsize(hamiltonian, initial_θ)\nintegrator = Leapfrog(initial_ϵ)\nkernel = HMCKernel(Trajectory{EndPointTS}(integrator, FixedIntegrationTime(λ)))\nadaptor = StepSizeAdaptor(δ, initial_ϵ)\nhmcda = HMCSampler(kernel, metric, adaptor)","category":"page"},{"location":"get_started/","page":"Get Started","title":"Get Started","text":"Moreover, there's some flexibility in how these samplers can be initialized. For example, a user can initialize a NUTS (HMC and HMCDA) sampler with their own metrics and integrators. This can be done as follows:","category":"page"},{"location":"get_started/","page":"Get Started","title":"Get Started","text":"nuts = NUTS(δ; metric=:diagonal) #metric = DiagEuclideanMetric(D) (Default!)\nnuts = NUTS(δ; metric=:unit)     #metric = UnitEuclideanMetric(D)\nnuts = NUTS(δ; metric=:dense)    #metric = DenseEuclideanMetric(D)\n# Provide your own AbstractMetric\nmetric = DiagEuclideanMetric(10)\nnuts = NUTS(δ; metric=metric)\n\nnuts = NUTS(δ; integrator=:leapfrog)         #integrator = Leapfrog(ϵ) (Default!)\nnuts = NUTS(δ; integrator=:jitteredleapfrog) #integrator = JitteredLeapfrog(ϵ, 0.1ϵ)\nnuts = NUTS(δ; integrator=:temperedleapfrog) #integrator = TemperedLeapfrog(ϵ, 1.0)\n\n# Provide your own AbstractIntegrator\nintegrator = JitteredLeapfrog(0.1, 0.2)\nnuts = NUTS(δ; integrator=integrator)","category":"page"},{"location":"get_started/#GPU-Sampling-with-CUDA","page":"Get Started","title":"GPU Sampling with CUDA","text":"","category":"section"},{"location":"get_started/","page":"Get Started","title":"Get Started","text":"There is experimental support for running static HMC on the GPU using CUDA. To do so, the user needs to have CUDA.jl installed, ensure the logdensity of the Hamiltonian can be executed on the GPU and that the initial points are a CuArray. A small working example can be found at test/cuda.jl.","category":"page"},{"location":"get_started/#Footnotes","page":"Get Started","title":"Footnotes","text":"","category":"section"},{"location":"get_started/","page":"Get Started","title":"Get Started","text":"[1]: The Euclidean metric is also known as the mass matrix in the physical perspective. See Hamiltonian mass matrix for available metrics.","category":"page"},{"location":"get_started/","page":"Get Started","title":"Get Started","text":"[2]: About the leapfrog integration scheme: Suppose bf x and bf v are the position and velocity of an individual particle respectively; i and i+1 are the indices for time values t_i and t_i+1 respectively; dt = t_i+1 - t_i is the time step size (constant and regularly spaced intervals), and bf a is the acceleration induced on a particle by the forces of all other particles. Furthermore, suppose positions are defined at times t_i t_i+1 t_i+2 dots  spaced at constant intervals dt, the velocities are defined at halfway times in between, denoted by t_i-12 t_i+12 t_i+32 dots  where t_i+1 - t_i + 12 = t_i + 12 - t_i = dt  2, and the accelerations bf a are defined only on integer times, just like the positions. Then the leapfrog integration scheme is given as: x_i = x_i-1 + v_i-12 dt quad v_i+12 = v_i-12 + a_i dt. For available integrators refer to Integrator.","category":"page"},{"location":"get_started/","page":"Get Started","title":"Get Started","text":"[3]: On kernels: In the classical HMC approach, during the first step, new values for the momentum variables are randomly drawn from their Gaussian distribution, independently of the current values of the position variables. A Metropolis update is performed during the second step, using Hamiltonian dynamics to provide a new state. For available kernels refer to Kernel.","category":"page"},{"location":"api/#Detailed-API-for-AdvancedHMC.jl","page":"Detailed API","title":"Detailed API for AdvancedHMC.jl","text":"","category":"section"},{"location":"api/","page":"Detailed API","title":"Detailed API","text":"An important design goal of AdvancedHMC.jl is modularity; we would like to support algorithmic research on HMC. This modularity means that different HMC variants can be easily constructed by composing various components, such as preconditioning metric (i.e., mass matrix), leapfrog integrators, trajectories (static or dynamic), adaption schemes, etc. In this section, we will explain the detailed usage of different modules in AdancedHMC.jl to provide a comprehensive udnerstanding of how AdvancedHMC.jl can achieve both modularity and efficiency. The section highlights the key components of AdvancedHMC.jl, with a complete documentation provided at the end.","category":"page"},{"location":"api/#hamiltonian_mm","page":"Detailed API","title":"Hamiltonian mass matrix (metric)","text":"","category":"section"},{"location":"api/","page":"Detailed API","title":"Detailed API","text":"Unit metric: UnitEuclideanMetric(dim)\nDiagonal metric: DiagEuclideanMetric(dim)\nDense metric: DenseEuclideanMetric(dim)","category":"page"},{"location":"api/","page":"Detailed API","title":"Detailed API","text":"where dim is the dimensionality of the sampling space.","category":"page"},{"location":"api/#integrator","page":"Detailed API","title":"Integrator (integrator)","text":"","category":"section"},{"location":"api/","page":"Detailed API","title":"Detailed API","text":"Ordinary leapfrog integrator: Leapfrog(ϵ)\nJittered leapfrog integrator with jitter rate n: JitteredLeapfrog(ϵ, n)\nTempered leapfrog integrator with tempering rate a: TemperedLeapfrog(ϵ, a)","category":"page"},{"location":"api/","page":"Detailed API","title":"Detailed API","text":"where ϵ is the step size of leapfrog integration.","category":"page"},{"location":"api/#kernel","page":"Detailed API","title":"Kernel (kernel)","text":"","category":"section"},{"location":"api/","page":"Detailed API","title":"Detailed API","text":"Static HMC with a fixed number of steps (n_steps) from Neal [1]: HMCKernel(Trajectory{EndPointTS}(integrator, FixedNSteps(integrator)))\nHMC with a fixed total trajectory length (trajectory_length) from Neal [1]: HMCKernel(Trajectory{EndPointTS}(integrator, FixedIntegrationTime(trajectory_length)))\nOriginal NUTS with slice sampling from Hoffman et al. [2]: HMCKernel(Trajectory{SliceTS}(integrator, ClassicNoUTurn()))\nGeneralised NUTS with slice sampling from Betancourt [3]: HMCKernel(Trajectory{SliceTS}(integrator, GeneralisedNoUTurn()))\nOriginal NUTS with multinomial sampling from Betancourt [3]: HMCKernel(Trajectory{MultinomialTS}(integrator, ClassicNoUTurn()))\nGeneralised NUTS with multinomial sampling from Betancourt [3]: HMCKernel(Trajectory{MultinomialTS}(integrator, GeneralisedNoUTurn()))","category":"page"},{"location":"api/#Adaptor-(adaptor)","page":"Detailed API","title":"Adaptor (adaptor)","text":"","category":"section"},{"location":"api/","page":"Detailed API","title":"Detailed API","text":"Adapt the mass matrix metric of the Hamiltonian dynamics: mma = MassMatrixAdaptor(metric)\nThis is lowered to UnitMassMatrix, WelfordVar or WelfordCov based on the type of the mass matrix metric\nAdapt the step size of the leapfrog integrator integrator: ssa = StepSizeAdaptor(δ, integrator)\nIt uses Nesterov's dual averaging with δ as the target acceptance rate.\nCombine the two above naively: NaiveHMCAdaptor(mma, ssa)\nCombine the first two using Stan's windowed adaptation: StanHMCAdaptor(mma, ssa)","category":"page"},{"location":"api/#The-sample-functions","page":"Detailed API","title":"The sample functions","text":"","category":"section"},{"location":"api/","page":"Detailed API","title":"Detailed API","text":"sample(\n    rng::Union{AbstractRNG,AbstractVector{<:AbstractRNG}},\n    h::Hamiltonian,\n    κ::HMCKernel,\n    θ::AbstractVector{<:AbstractFloat},\n    n_samples::Int;\n    adaptor::AbstractAdaptor=NoAdaptation(),\n    n_adapts::Int=min(div(n_samples, 10), 1_000),\n    drop_warmup=false,\n    verbose::Bool=true,\n    progress::Bool=false,\n)","category":"page"},{"location":"api/","page":"Detailed API","title":"Detailed API","text":"Draw n_samples samples using the kernel κ under the Hamiltonian system h","category":"page"},{"location":"api/","page":"Detailed API","title":"Detailed API","text":"The randomness is controlled by rng.\nIf rng is not provided, the default random number generator (Random.default_rng()) will be used.\nThe initial point is given by θ.\nThe adaptor is set by adaptor, for which the default is no adaptation.\nIt will perform n_adapts steps of adaptation, for which the default is 1_000 or 10% of n_samples, whichever is lower.\ndrop_warmup specifies whether to drop samples.\nverbose controls the verbosity.\nprogress controls whether to show the progress meter or not.","category":"page"},{"location":"api/","page":"Detailed API","title":"Detailed API","text":"Note that the function signature of the sample function exported by AdvancedHMC.jl differs from the sample function used by Turing.jl. We refer to the documentation of Turing.jl for more details on the latter.","category":"page"},{"location":"api/#Full-documentation-of-APIs-in-AdvancedHMC.jl","page":"Detailed API","title":"Full documentation of APIs in AdvancedHMC.jl","text":"","category":"section"},{"location":"api/","page":"Detailed API","title":"Detailed API","text":"Modules = [AdvancedHMC, AdvancedHMC.Adaptation]\nOrder   = [:type]","category":"page"},{"location":"api/#AdvancedHMC.AbstractIntegrator-api","page":"Detailed API","title":"AdvancedHMC.AbstractIntegrator","text":"abstract type AbstractIntegrator\n\nRepresents an integrator used to simulate the Hamiltonian system.\n\nImplementation\n\nA AbstractIntegrator is expected to have the following implementations:\n\nstat(@ref)\nnom_step_size(@ref)\nstep_size(@ref)\n\n\n\n\n\n","category":"type"},{"location":"api/#AdvancedHMC.AbstractMCMCKernel-api","page":"Detailed API","title":"AdvancedHMC.AbstractMCMCKernel","text":"abstract type AbstractMCMCKernel\n\nAbstract type for HMC kernels. \n\n\n\n\n\n","category":"type"},{"location":"api/#AdvancedHMC.AbstractMetric-api","page":"Detailed API","title":"AdvancedHMC.AbstractMetric","text":"abstract type AbstractMetric\n\nAbstract type for preconditioning metrics. \n\n\n\n\n\n","category":"type"},{"location":"api/#AdvancedHMC.AbstractTerminationCriterion-api","page":"Detailed API","title":"AdvancedHMC.AbstractTerminationCriterion","text":"abstract type AbstractTerminationCriterion\n\nAbstract type for termination criteria for Hamiltonian trajectories, e.g. no-U-turn and fixed number of leapfrog integration steps. \n\n\n\n\n\n","category":"type"},{"location":"api/#AdvancedHMC.AbstractTrajectorySampler-api","page":"Detailed API","title":"AdvancedHMC.AbstractTrajectorySampler","text":"How to sample a phase-point from the simulated trajectory.\n\n\n\n\n\n","category":"type"},{"location":"api/#AdvancedHMC.BinaryTree-api","page":"Detailed API","title":"AdvancedHMC.BinaryTree","text":"A full binary tree trajectory with only necessary leaves and information stored.\n\n\n\n\n\n","category":"type"},{"location":"api/#AdvancedHMC.ClassicNoUTurn-api","page":"Detailed API","title":"AdvancedHMC.ClassicNoUTurn","text":"struct ClassicNoUTurn{F<:AbstractFloat} <: AdvancedHMC.DynamicTerminationCriterion\n\nClassic No-U-Turn criterion as described in Eq. (9) in [1].\n\nInformally, this will terminate the trajectory expansion if continuing the simulation either forwards or backwards in time will decrease the distance between the left-most and right-most positions.\n\nFields\n\nmax_depth::Int64\nΔ_max::AbstractFloat\n\nReferences\n\nHoffman, M. D., & Gelman, A. (2014). The No-U-Turn Sampler: adaptively setting path lengths in Hamiltonian Monte Carlo. Journal of Machine Learning Research, 15(1), 1593-1623. (arXiv)\n\n\n\n\n\n","category":"type"},{"location":"api/#AdvancedHMC.DynamicTerminationCriterion-api","page":"Detailed API","title":"AdvancedHMC.DynamicTerminationCriterion","text":"abstract type DynamicTerminationCriterion <: AdvancedHMC.AbstractTerminationCriterion\n\nAbstract type for dynamic Hamiltonian trajectory termination criteria. \n\n\n\n\n\n","category":"type"},{"location":"api/#AdvancedHMC.EndPointTS-api","page":"Detailed API","title":"AdvancedHMC.EndPointTS","text":"Samples the end-point of the trajectory.\n\n\n\n\n\n","category":"type"},{"location":"api/#AdvancedHMC.FixedIntegrationTime-api","page":"Detailed API","title":"AdvancedHMC.FixedIntegrationTime","text":"struct FixedIntegrationTime{F<:AbstractFloat} <: AdvancedHMC.StaticTerminationCriterion\n\nStandard HMC implementation with a fixed integration time.\n\nFields\n\nλ::AbstractFloat: Total length of the trajectory, i.e. take floor(λ / integrator_step_size) number of leapfrog steps.\n\nReferences\n\nNeal, R. M. (2011). MCMC using Hamiltonian dynamics. Handbook of Markov chain Monte Carlo, 2(11), 2. (arXiv) \n\n\n\n\n\n","category":"type"},{"location":"api/#AdvancedHMC.FixedNSteps-api","page":"Detailed API","title":"AdvancedHMC.FixedNSteps","text":"struct FixedNSteps <: AdvancedHMC.StaticTerminationCriterion\n\nStatic HMC with a fixed number of leapfrog steps.\n\nFields\n\nL::Int64: Number of steps to simulate, i.e. length of trajectory will be L + 1.\n\nReferences\n\nNeal, R. M. (2011). MCMC using Hamiltonian dynamics. Handbook of Markov chain Monte Carlo, 2(11), 2. (arXiv)\n\n\n\n\n\n","category":"type"},{"location":"api/#AdvancedHMC.FullMomentumRefreshment-api","page":"Detailed API","title":"AdvancedHMC.FullMomentumRefreshment","text":"Completly resample new momentum.\n\n\n\n\n\n","category":"type"},{"location":"api/#AdvancedHMC.GeneralisedNoUTurn-api","page":"Detailed API","title":"AdvancedHMC.GeneralisedNoUTurn","text":"struct GeneralisedNoUTurn{F<:AbstractFloat} <: AdvancedHMC.DynamicTerminationCriterion\n\nGeneralised No-U-Turn criterion as described in Section A.4.2 in [1].\n\nFields\n\nmax_depth::Int64\nΔ_max::AbstractFloat\n\nReferences\n\nBetancourt, M. (2017). A Conceptual Introduction to Hamiltonian Monte Carlo. arXiv preprint arXiv:1701.02434.\n\n\n\n\n\n","category":"type"},{"location":"api/#AdvancedHMC.GeneralizedLeapfrog-api","page":"Detailed API","title":"AdvancedHMC.GeneralizedLeapfrog","text":"struct GeneralizedLeapfrog{T<:(Union{AbstractVector{var\"#s20\"}, var\"#s20\"} where var\"#s20\"<:AbstractFloat)} <: AdvancedHMC.AbstractLeapfrog{T<:(Union{AbstractVector{var\"#s20\"}, var\"#s20\"} where var\"#s20\"<:AbstractFloat)}\n\nGeneralized leapfrog integrator with fixed step size ϵ.\n\nFields\n\nϵ::Union{AbstractVector{var\"#s20\"}, var\"#s20\"} where var\"#s20\"<:AbstractFloat: Step size.\nn::Int64\n\nReferences\n\nGirolami, Mark, and Ben Calderhead. \"Riemann manifold Langevin and Hamiltonian Monte Carlo methods.\" Journal of the Royal Statistical Society Series B: Statistical Methodology 73, no. 2 (2011): 123-214.\n\n\n\n\n\n","category":"type"},{"location":"api/#AdvancedHMC.HMC-api","page":"Detailed API","title":"AdvancedHMC.HMC","text":"HMC(ϵ::Real, n_leapfrog::Int)\n\nHamiltonian Monte Carlo sampler with static trajectory.\n\nFields\n\nn_leapfrog: Number of leapfrog steps.\nintegrator: Choice of integrator, specified either using a Symbol or AbstractIntegrator\nmetric: Choice of initial metric;  Symbol means it is automatically initialised. The metric type will be preserved during automatic initialisation and adaption.\n\n\n\n\n\n","category":"type"},{"location":"api/#AdvancedHMC.HMCDA-api","page":"Detailed API","title":"AdvancedHMC.HMCDA","text":"HMCDA(δ::Real, λ::Real, integrator = :leapfrog, metric = :diagonal)\n\nHamiltonian Monte Carlo sampler with Dual Averaging algorithm.\n\nFields\n\nδ: Target acceptance rate for dual averaging.\nλ: Target leapfrog length.\nintegrator: Choice of integrator, specified either using a Symbol or AbstractIntegrator\nmetric: Choice of initial metric;  Symbol means it is automatically initialised. The metric type will be preserved during automatic initialisation and adaption.\n\nNotes\n\nFor more information, please view the following paper (arXiv link):\n\nHoffman, Matthew D., and Andrew Gelman. \"The No-U-turn sampler: adaptively setting path lengths in Hamiltonian Monte Carlo.\" Journal of Machine Learning Research 15, no. 1 (2014): 1593-1623.\n\n\n\n\n\n","category":"type"},{"location":"api/#AdvancedHMC.HMCProgressCallback-api","page":"Detailed API","title":"AdvancedHMC.HMCProgressCallback","text":"HMCProgressCallback\n\nA callback to be used with AbstractMCMC.jl's interface, replicating the logging behavior of the non-AbstractMCMC sample.\n\nFields\n\npm: Progress meter from ProgressMeters.jl, or nothing.\nverbose: If pm === nothing and this is true some information will be logged upon completion of adaptation.\nnum_divergent_transitions: Number of divergent transitions.\nnum_divergent_transitions_during_adaption\n\n\n\n\n\n","category":"type"},{"location":"api/#AdvancedHMC.HMCSampler-api","page":"Detailed API","title":"AdvancedHMC.HMCSampler","text":"HMCSampler\n\nAn AbstractMCMC.AbstractSampler for kernels in AdvancedHMC.jl.\n\nFields\n\nκ: AbstractMCMCKernel.\nmetric: Choice of initial metric AbstractMetric. The metric type will be preserved during adaption.\nadaptor: AdvancedHMC.Adaptation.AbstractAdaptor.\n\nNotes\n\nNote that all the fields have the prefix initial_ to indicate that these will not necessarily correspond to the kernel, metric, and adaptor after sampling.\n\nTo access the updated fields, use the resulting HMCState.\n\n\n\n\n\n","category":"type"},{"location":"api/#AdvancedHMC.HMCState-api","page":"Detailed API","title":"AdvancedHMC.HMCState","text":"HMCState\n\nRepresents the state of a HMCSampler.\n\nFields\n\ni: Index of current iteration.\ntransition: Current Transition.\nmetric: Current AbstractMetric, possibly adapted.\nκ: Current AbstractMCMCKernel.\nadaptor: Current AbstractAdaptor.\n\n\n\n\n\n","category":"type"},{"location":"api/#AdvancedHMC.JitteredLeapfrog-api","page":"Detailed API","title":"AdvancedHMC.JitteredLeapfrog","text":"struct JitteredLeapfrog{FT<:AbstractFloat, T<:Union{AbstractArray{FT<:AbstractFloat, 1}, FT<:AbstractFloat}} <: AdvancedHMC.AbstractLeapfrog{T<:Union{AbstractArray{FT<:AbstractFloat, 1}, FT<:AbstractFloat}}\n\nLeapfrog integrator with randomly \"jittered\" step size ϵ for every trajectory.\n\nFields\n\nϵ0::Union{AbstractVector{FT}, FT} where FT<:AbstractFloat: Nominal (non-jittered) step size.\njitter::AbstractFloat: The proportion of the nominal step size ϵ0 that may be added or subtracted.\nϵ::Union{AbstractVector{FT}, FT} where FT<:AbstractFloat: Current (jittered) step size.\n\nDescription\n\nThis is the same as LeapFrog(@ref) but with a \"jittered\" step size. This means  that at the beginning of each trajectory we sample a step size ϵ by adding or  subtracting from the nominal/base step size ϵ0 some random proportion of ϵ0,  with the proportion specified by jitter, i.e. ϵ = ϵ0 - jitter * ϵ0 * rand(). p Jittering might help alleviate issues related to poor interactions with a fixed step size:\n\nIn regions with high \"curvature\" the current choice of step size might mean over-shoot  leading to almost all steps being rejected. Randomly sampling the step size at the  beginning of the trajectories can therefore increase the probability of escaping such high-curvature regions.\nExact periodicity of the simulated trajectories might occur, i.e. you might be so unlucky as to simulate the trajectory forwards in time L ϵ and ending up at the same point (which results in non-ergodicity; see Section 3.2 in [1]). If momentum is refreshed before each trajectory, then this should not happen exactly but it can still be an issue in practice. Randomly choosing the step-size ϵ might help alleviate such problems.\n\nReferences\n\nNeal, R. M. (2011). MCMC using Hamiltonian dynamics. Handbook of Markov chain Monte Carlo, 2(11), 2. (arXiv)\n\n\n\n\n\n","category":"type"},{"location":"api/#AdvancedHMC.Leapfrog-api","page":"Detailed API","title":"AdvancedHMC.Leapfrog","text":"struct Leapfrog{T<:(Union{AbstractVector{var\"#s29\"}, var\"#s29\"} where var\"#s29\"<:AbstractFloat)} <: AdvancedHMC.AbstractLeapfrog{T<:(Union{AbstractVector{var\"#s29\"}, var\"#s29\"} where var\"#s29\"<:AbstractFloat)}\n\nLeapfrog integrator with fixed step size ϵ.\n\nFields\n\nϵ::Union{AbstractVector{var\"#s29\"}, var\"#s29\"} where var\"#s29\"<:AbstractFloat: Step size.\n\n\n\n\n\n","category":"type"},{"location":"api/#AdvancedHMC.MultinomialTS-Tuple{MultinomialTS, AbstractFloat, AdvancedHMC.PhasePoint}-api","page":"Detailed API","title":"AdvancedHMC.MultinomialTS","text":"struct MultinomialTS{F<:AbstractFloat, P<:AdvancedHMC.PhasePoint} <: AdvancedHMC.AbstractTrajectorySampler\n\nMultinomial sampler for a trajectory consisting only a leaf node.\n\ntree weight is the (unnormalised) energy of the leaf.\n\n\n\n\n\n","category":"method"},{"location":"api/#AdvancedHMC.MultinomialTS-Tuple{Random.AbstractRNG, AdvancedHMC.PhasePoint}-api","page":"Detailed API","title":"AdvancedHMC.MultinomialTS","text":"struct MultinomialTS{F<:AbstractFloat, P<:AdvancedHMC.PhasePoint} <: AdvancedHMC.AbstractTrajectorySampler\n\nMultinomial sampler for the starting single leaf tree. (Log) weights for leaf nodes are their (unnormalised) Hamiltonian energies.\n\nRef: https://github.com/stan-dev/stan/blob/develop/src/stan/mcmc/hmc/nuts/base_nuts.hpp#L226\n\n\n\n\n\n","category":"method"},{"location":"api/#AdvancedHMC.MultinomialTS-api","page":"Detailed API","title":"AdvancedHMC.MultinomialTS","text":"struct MultinomialTS{F<:AbstractFloat, P<:AdvancedHMC.PhasePoint} <: AdvancedHMC.AbstractTrajectorySampler\n\nMultinomial trajectory sampler carried during the building of the tree. It contains the weight of the tree, defined as the total probabilities of the leaves.\n\nFields\n\nzcand::AdvancedHMC.PhasePoint: Sampled candidate PhasePoint.\nℓw::AbstractFloat: Total energy for the given tree, i.e. the sum of energies of all leaves.\n\n\n\n\n\n","category":"type"},{"location":"api/#AdvancedHMC.NUTS-api","page":"Detailed API","title":"AdvancedHMC.NUTS","text":"NUTS(δ::Real; max_depth::Int=10, Δ_max::Real=1000, integrator = :leapfrog, metric = :diagonal)\n\nNo-U-Turn Sampler (NUTS) sampler.\n\nFields\n\nδ: Target acceptance rate for dual averaging.\nmax_depth: Maximum doubling tree depth.\nΔ_max: Maximum divergence during doubling tree.\nintegrator: Choice of integrator, specified either using a Symbol or AbstractIntegrator\nmetric: Choice of initial metric;  Symbol means it is automatically initialised. The metric type will be preserved during automatic initialisation and adaption.\n\n\n\n\n\n","category":"type"},{"location":"api/#AdvancedHMC.PartialMomentumRefreshment-api","page":"Detailed API","title":"AdvancedHMC.PartialMomentumRefreshment","text":"struct PartialMomentumRefreshment{F<:AbstractFloat} <: AdvancedHMC.AbstractMomentumRefreshment\n\nPartial momentum refreshment with refresh rate α.\n\nFields\n\nα::AbstractFloat\n\nSee equation (5.19) [1]\n\nr' = α⋅r + sqrt(1-α²)⋅G\n\nwhere r is the momentum and G is a Gaussian random variable.\n\nReferences\n\nNeal, Radford M. \"MCMC using Hamiltonian dynamics.\" Handbook of markov chain monte carlo 2.11 (2011): 2.\n\n\n\n\n\n","category":"type"},{"location":"api/#AdvancedHMC.SliceTS-Tuple{Random.AbstractRNG, AdvancedHMC.PhasePoint}-api","page":"Detailed API","title":"AdvancedHMC.SliceTS","text":"struct SliceTS{F<:AbstractFloat, P<:AdvancedHMC.PhasePoint} <: AdvancedHMC.AbstractTrajectorySampler\n\nSlice sampler for the starting single leaf tree. Slice variable is initialized.\n\n\n\n\n\n","category":"method"},{"location":"api/#AdvancedHMC.SliceTS-Tuple{SliceTS, AbstractFloat, AdvancedHMC.PhasePoint}-api","page":"Detailed API","title":"AdvancedHMC.SliceTS","text":"struct SliceTS{F<:AbstractFloat, P<:AdvancedHMC.PhasePoint} <: AdvancedHMC.AbstractTrajectorySampler\n\nCreate a slice sampler for a single leaf tree:\n\nthe slice variable is copied from the passed-in sampler s and\nthe number of acceptable candicates is computed by comparing the slice variable against the current energy.\n\n\n\n\n\n","category":"method"},{"location":"api/#AdvancedHMC.SliceTS-api","page":"Detailed API","title":"AdvancedHMC.SliceTS","text":"struct SliceTS{F<:AbstractFloat, P<:AdvancedHMC.PhasePoint} <: AdvancedHMC.AbstractTrajectorySampler\n\nTrajectory slice sampler carried during the building of the tree. It contains the slice variable and the number of acceptable condidates in the tree.\n\nFields\n\nzcand::AdvancedHMC.PhasePoint: Sampled candidate PhasePoint.\nℓu::AbstractFloat: Slice variable in log-space.\nn::Int64: Number of acceptable candidates, i.e. those with probability larger than slice variable u.\n\n\n\n\n\n","category":"type"},{"location":"api/#AdvancedHMC.StaticTerminationCriterion-api","page":"Detailed API","title":"AdvancedHMC.StaticTerminationCriterion","text":"abstract type StaticTerminationCriterion <: AdvancedHMC.AbstractTerminationCriterion\n\nAbstract type for a fixed number of leapfrog integration steps.\n\n\n\n\n\n","category":"type"},{"location":"api/#AdvancedHMC.StrictGeneralisedNoUTurn-api","page":"Detailed API","title":"AdvancedHMC.StrictGeneralisedNoUTurn","text":"struct StrictGeneralisedNoUTurn{F<:AbstractFloat} <: AdvancedHMC.DynamicTerminationCriterion\n\nGeneralised No-U-Turn criterion as described in Section A.4.2 in [1] with  added U-turn check as described in [2].\n\nFields\n\nmax_depth::Int64\nΔ_max::AbstractFloat\n\nReferences\n\nBetancourt, M. (2017). A Conceptual Introduction to Hamiltonian Monte Carlo. arXiv preprint arXiv:1701.02434.\nhttps://github.com/stan-dev/stan/pull/2800\n\n\n\n\n\n","category":"type"},{"location":"api/#AdvancedHMC.TemperedLeapfrog-api","page":"Detailed API","title":"AdvancedHMC.TemperedLeapfrog","text":"struct TemperedLeapfrog{FT<:AbstractFloat, T<:Union{AbstractArray{FT<:AbstractFloat, 1}, FT<:AbstractFloat}} <: AdvancedHMC.AbstractLeapfrog{T<:Union{AbstractArray{FT<:AbstractFloat, 1}, FT<:AbstractFloat}}\n\nTempered leapfrog integrator with fixed step size ϵ and \"temperature\" α.\n\nFields\n\nϵ::Union{AbstractVector{FT}, FT} where FT<:AbstractFloat: Step size.\nα::AbstractFloat: Temperature parameter.\n\nDescription\n\nTempering can potentially allow greater exploration of the posterior, e.g.  in a multi-modal posterior jumps between the modes can be more likely to occur.\n\n\n\n\n\n","category":"type"},{"location":"api/#AdvancedHMC.Termination-Union{Tuple{F}, Tuple{MultinomialTS, Trajectory, F, F}} where F<:AbstractFloat-api","page":"Detailed API","title":"AdvancedHMC.Termination","text":"Termination(s, nt, H0, H′)\n\n\nCheck termination of a Hamiltonian trajectory.\n\n\n\n\n\n","category":"method"},{"location":"api/#AdvancedHMC.Termination-Union{Tuple{F}, Tuple{SliceTS, Trajectory, F, F}} where F<:AbstractFloat-api","page":"Detailed API","title":"AdvancedHMC.Termination","text":"Termination(s, nt, H0, H′)\n\n\nCheck termination of a Hamiltonian trajectory.\n\n\n\n\n\n","category":"method"},{"location":"api/#AdvancedHMC.Termination-api","page":"Detailed API","title":"AdvancedHMC.Termination","text":"Termination\n\nTermination reasons\n\ndynamic: due to stoping criteria\nnumerical: due to large energy deviation from starting (possibly numerical errors)\n\n\n\n\n\n","category":"type"},{"location":"api/#AdvancedHMC.Trajectory-api","page":"Detailed API","title":"AdvancedHMC.Trajectory","text":"struct Trajectory{TS<:AdvancedHMC.AbstractTrajectorySampler, I<:AdvancedHMC.AbstractIntegrator, TC<:AdvancedHMC.AbstractTerminationCriterion}\n\nNumerically simulated Hamiltonian trajectories.\n\n\n\n\n\n","category":"type"},{"location":"api/#AdvancedHMC.Transition-api","page":"Detailed API","title":"AdvancedHMC.Transition","text":"struct Transition{P<:AdvancedHMC.PhasePoint, NT<:NamedTuple}\n\nA transition that contains the phase point and other statistics of the transition.\n\nFields\n\nz::AdvancedHMC.PhasePoint: Phase-point for the transition.\nstat::NamedTuple: Statistics related to the transition, e.g. energy.\n\n\n\n\n\n","category":"type"},{"location":"api/#AdvancedHMC.Adaptation.AbstractAdaptor-api","page":"Detailed API","title":"AdvancedHMC.Adaptation.AbstractAdaptor","text":"abstract type AbstractAdaptor\n\nAbstract type for HMC adaptors. \n\n\n\n\n\n","category":"type"},{"location":"api/#AdvancedHMC.Adaptation.NesterovDualAveraging-api","page":"Detailed API","title":"AdvancedHMC.Adaptation.NesterovDualAveraging","text":"An implementation of the Nesterov dual averaging algorithm to tune step size.\n\nReferences\n\nHoffman, M. D., & Gelman, A. (2014). The No-U-Turn Sampler: adaptively setting path lengths in Hamiltonian Monte Carlo. Journal of Machine Learning Research, 15(1), 1593-1623. Nesterov, Y. (2009). Primal-dual subgradient methods for convex problems. Mathematical programming, 120(1), 221-259.\n\n\n\n\n\n","category":"type"},{"location":"interfaces/#Interfaces","page":"Interfaces","title":"Interfaces","text":"","category":"section"},{"location":"interfaces/","page":"Interfaces","title":"Interfaces","text":"IMP.hmc: an experimental Python module for the Integrative Modeling Platform, which uses AdvancedHMC in its backend to sample protein structures.","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"R. M. Neal. Mcmc using Hamiltonian dynamics (handbook of Markov Chain Monte Carlo). A Gelman, G Jones XL Meng (2011).\n\n\n\nM. D. Hoffman, A. Gelman and others. The No-U-Turn sampler: adaptively setting path lengths in Hamiltonian Monte Carlo. J. Mach. Learn. Res. 15, 1593–1623 (2014).\n\n\n\nM. Betancourt. A conceptual introduction to Hamiltonian Monte Carlo, arXiv preprint arXiv:1701.02434 (2017).\n\n\n\n","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"CHANGELOG","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"[v0.5.0] Breaking! Convenience constructors for common samplers changed to:\nHMC(leapfrog_stepsize::Real, n_leapfrog::Int)\nNUTS(target_acceptance::Real)\nHMCDA(target_acceptance::Real, integration_time::Real)\n[v0.2.22] Three functions are renamed.\nPreconditioner(metric::AbstractMetric) -> MassMatrixAdaptor(metric) and\nNesterovDualAveraging(δ, integrator::AbstractIntegrator) -> StepSizeAdaptor(δ, integrator)\nfind_good_eps -> find_good_stepsize\n[v0.2.15] n_adapts is no longer needed to construct StanHMCAdaptor; the old constructor is deprecated.\n[v0.2.8] Two Hamiltonian trajectory sampling methods are renamed to avoid a name clash with Distributions.\nMultinomial -> MultinomialTS\nSlice -> SliceTS\n[v0.2.0] The gradient function passed to Hamiltonian is supposed to return a value-gradient tuple now.","category":"page"},{"location":"news/#NEWS","page":"News","title":"NEWS","text":"","category":"section"},{"location":"news/","page":"News","title":"News","text":"We presented a paper for AdvancedHMC.jl at AABI in 2019 in Vancouver, Canada. (abs, pdf, OpenReview)\nWe presented a poster for AdvancedHMC.jl at StanCon 2019 in Cambridge, UK. (pdf)","category":"page"},{"location":"#AdvancedHMC.jl","page":"AdvancedHMC.jl","title":"AdvancedHMC.jl","text":"","category":"section"},{"location":"","page":"AdvancedHMC.jl","title":"AdvancedHMC.jl","text":"(Image: CI) (Image: DOI) (Image: Coverage Status) (Image: Stable) (Image: Dev) (Image: Aqua QA)","category":"page"},{"location":"","page":"AdvancedHMC.jl","title":"AdvancedHMC.jl","text":"AdvancedHMC.jl provides a robust, modular, and efficient implementation of advanced Hamiltonian Monte Carlo(HMC) algorithms. AdvancedHMC.jl is part of Turing.jl, a probabilistic programming library in Julia. If you are interested in using AdvancedHMC.jl through a probabilistic programming language, please check it out!","category":"page"},{"location":"#Citing-AdvancedHMC.jl","page":"AdvancedHMC.jl","title":"Citing AdvancedHMC.jl","text":"","category":"section"},{"location":"","page":"AdvancedHMC.jl","title":"AdvancedHMC.jl","text":"If you use AdvancedHMC.jl for your own research, please consider citing the following publication:","category":"page"},{"location":"","page":"AdvancedHMC.jl","title":"AdvancedHMC.jl","text":"Kai Xu, Hong Ge, Will Tebbutt, Mohamed Tarek, Martin Trapp, Zoubin Ghahramani: \"AdvancedHMC.jl: A robust, modular and efficient implementation of advanced HMC algorithms.\", Symposium on Advances in Approximate Bayesian Inference, 2020. (abs, pdf)","category":"page"},{"location":"","page":"AdvancedHMC.jl","title":"AdvancedHMC.jl","text":"with the following BibTeX entry:","category":"page"},{"location":"","page":"AdvancedHMC.jl","title":"AdvancedHMC.jl","text":"@inproceedings{xu2020advancedhmc,\n  title={AdvancedHMC. jl: A robust, modular and efficient implementation of advanced HMC algorithms},\n  author={Xu, Kai and Ge, Hong and Tebbutt, Will and Tarek, Mohamed and Trapp, Martin and Ghahramani, Zoubin},\n  booktitle={Symposium on Advances in Approximate Bayesian Inference},\n  pages={1--10},\n  year={2020},\n  organization={PMLR}\n}","category":"page"},{"location":"","page":"AdvancedHMC.jl","title":"AdvancedHMC.jl","text":"If you using AdvancedHMC.jl directly through Turing.jl, please consider citing the following publication:","category":"page"},{"location":"","page":"AdvancedHMC.jl","title":"AdvancedHMC.jl","text":"Hong Ge, Kai Xu, and Zoubin Ghahramani: \"Turing: a language for flexible probabilistic inference.\", International Conference on Artificial Intelligence and Statistics, 2018. (abs, pdf)","category":"page"},{"location":"","page":"AdvancedHMC.jl","title":"AdvancedHMC.jl","text":"with the following BibTeX entry:","category":"page"},{"location":"","page":"AdvancedHMC.jl","title":"AdvancedHMC.jl","text":"@inproceedings{ge2018turing,\n  title={Turing: A language for flexible probabilistic inference},\n  author={Ge, Hong and Xu, Kai and Ghahramani, Zoubin},\n  booktitle={International Conference on Artificial Intelligence and Statistics},\n  pages={1682--1690},\n  year={2018},\n  organization={PMLR}\n}","category":"page"},{"location":"#References","page":"AdvancedHMC.jl","title":"References","text":"","category":"section"},{"location":"","page":"AdvancedHMC.jl","title":"AdvancedHMC.jl","text":"Neal, R. M. (2011). MCMC using Hamiltonian dynamics. Handbook of Markov chain Monte Carlo, 2(11), 2. (arXiv)\nHoffman, M. D., & Gelman, A. (2014). The No-U-Turn Sampler: adaptively setting path lengths in Hamiltonian Monte Carlo. Journal of Machine Learning Research, 15(1), 1593-1623. (arXiv)\nBetancourt, M. (2017). A Conceptual Introduction to Hamiltonian Monte Carlo. arXiv preprint arXiv:1701.02434.\nGirolami, M., & Calderhead, B. (2011). Riemann manifold Langevin and Hamiltonian Monte Carlo methods. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 73(2), 123-214. (arXiv)\nBetancourt, M. J., Byrne, S., & Girolami, M. (2014). Optimizing the integrator step size for Hamiltonian Monte Carlo. arXiv preprint arXiv:1411.6669.\nBetancourt, M. (2016). Identifying the optimal integration time in Hamiltonian Monte Carlo. arXiv preprint arXiv:1601.00225.\n","category":"page"},{"location":"autodiff/#Gradient-in-AdvancedHMC.jl","page":"Automatic Differentiation Backends","title":"Gradient in AdvancedHMC.jl","text":"","category":"section"},{"location":"autodiff/","page":"Automatic Differentiation Backends","title":"Automatic Differentiation Backends","text":"AdvancedHMC.jl supports automatic differentiation using LogDensityProblemsAD across various AD backends and allows user-specified gradients. While the default AD backend for AdvancedHMC.jl is ForwardDiff.jl, we can seamlessly change to other backend like Mooncake.jl using various syntax like Hamiltonian(metric, ℓπ, AutoZygote()). Different AD backend can also be pluged in using Hamiltonian(metric, ℓπ, Zygote), Hamiltonian(metric, ℓπ, Val(:Zygote)) but we recommend using ADTypes since that would allow you to have more freedom for specifying the AD backend.","category":"page"},{"location":"autodiff/","page":"Automatic Differentiation Backends","title":"Automatic Differentiation Backends","text":"In order to use user-specified gradients, please replace ForwardDiff.jl with ℓπ_grad in the Hamiltonian constructor as Hamiltonian(metric, ℓπ, ℓπ_grad), where the gradient function ℓπ_grad should return a tuple containing both the log-posterior and its gradient, for example ℓπ_grad(x) = (log_posterior, grad).","category":"page"}]
}
